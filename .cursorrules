# React + TypeScript + PixiJS 프로젝트 규칙

당신은 React, TypeScript, PixiJS, Zustand를 사용한 게임 개발 전문가입니다.

## Git 및 터미널 규칙
- 절대 스스로 git 명령어를 실행하지 마십시오.
- 변경 사항이 완료되면 나에게 커밋할 준비가 되었다고 보고만 하십시오.
- 커밋은 오직 사용자가 직접 검토한 후 실행합니다.

## 핵심 원칙

- 간결하고 기술적인 TypeScript/React 코드를 작성합니다.
- 함수형 프로그래밍과 선언적 패턴을 사용합니다.
- 코드 중복보다는 반복과 모듈화를 선호합니다.
- 보조 동사를 사용한 서술적인 변수명을 사용합니다 (예: `isLoading`, `hasError`).
- 디렉토리명은 소문자와 대시를 사용합니다 (예: `game-entities`, `ui-components`).

## TypeScript

- TypeScript 5.4+ 기능을 활용합니다.
- **Strict 모드** 사용: 모든 strict 옵션 활성화.
- 명시적 타입 정의를 선호하며, `any` 사용을 최소화합니다.
- Interface보다 Type을 사용하되, 확장 가능한 객체에는 Interface를 사용합니다.
- `import type`으로 타입 임포트를 분리합니다.
- Utility Types를 적극 활용합니다 (`Partial`, `Pick`, `Omit`, `Record` 등).

```typescript
// Good
import type { CatState } from './types';
import { create } from 'zustand';

interface Position {
  x: number;
  y: number;
}

// Bad
import { CatState, create } from './mixed-imports';
```

## React

- **함수형 컴포넌트**만 사용합니다 (클래스 컴포넌트 금지).
- Custom Hooks로 로직을 재사용합니다.
- `useEffect`는 최소화하고, 의존성 배열을 정확히 관리합니다.
- 조기 반환(Early Return)을 사용하여 중첩을 줄입니다.
- Props는 구조 분해하여 사용합니다.
- 컴포넌트당 하나의 책임만 갖도록 합니다 (Single Responsibility).

```typescript
// Good
const Component = ({ isLoading, data }: Props) => {
  if (isLoading) return <Spinner />;
  if (!data) return null;
  
  return <div>{data.content}</div>;
};

// Bad
const Component = (props: Props) => {
  return (
    <div>
      {props.isLoading ? (
        <Spinner />
      ) : props.data ? (
        <div>{props.data.content}</div>
      ) : null}
    </div>
  );
};
```

## PixiJS 통합

- PixiJS 리소스는 반드시 클린업합니다 (`destroy()` 호출).
- `useRef`로 PIXI Application과 스프라이트를 관리합니다.
- 게임 루프는 `requestAnimationFrame` 또는 `app.ticker` 사용.
- PixiJS 로직과 React 컴포넌트를 명확히 분리합니다.
- 게임 엔티티는 별도 클래스로 분리합니다 (`game/entities/`).

```typescript
// Good: 게임 로직과 UI 분리
// game/entities/Player.ts
export class Player {
  sprite: PIXI.Sprite;
  
  constructor(x: number, y: number) {
    this.sprite = PIXI.Sprite.from('player.png');
    this.sprite.position.set(x, y);
  }
  
  update(delta: number) {
    // 게임 로직
  }
  
  destroy() {
    this.sprite.destroy();
  }
}

// components/GameCanvas.tsx
const GameCanvas = () => {
  const playerRef = useRef<Player | null>(null);
  
  useEffect(() => {
    const player = new Player(100, 100);
    playerRef.current = player;
    
    return () => {
      player.destroy();
    };
  }, []);
  
  return <div ref={canvasRef} />;
};
```

## Zustand 상태 관리

- 작고 집중된 스토어를 생성합니다.
- 불변성을 유지하며 상태를 업데이트합니다.
- Selectors를 사용하여 불필요한 리렌더링을 방지합니다.
- 액션과 상태를 같은 스토어에 정의합니다.
- 복잡한 로직은 스토어 외부에서 처리 후 결과만 업데이트합니다.

```typescript
// Good
interface GameStore {
  score: number;
  lives: number;
  increaseScore: (amount: number) => void;
  decreaseLives: () => void;
  reset: () => void;
}

export const useGameStore = create<GameStore>((set) => ({
  score: 0,
  lives: 3,
  increaseScore: (amount) => set((state) => ({ score: state.score + amount })),
  decreaseLives: () => set((state) => ({ lives: state.lives - 1 })),
  reset: () => set({ score: 0, lives: 3 }),
}));

// 컴포넌트에서 Selector 사용
const score = useGameStore((state) => state.score);
const increaseScore = useGameStore((state) => state.increaseScore);
```

## 파일 구조

```
src/
├── components/          # React 컴포넌트
│   ├── ui/             # 재사용 가능한 UI 컴포넌트
│   └── game/           # 게임 관련 컴포넌트
├── game/               # 게임 로직
│   ├── entities/       # 게임 엔티티 (Player, Enemy 등)
│   ├── systems/        # 게임 시스템 (Physics, Input 등)
│   └── utils/          # 게임 유틸리티
├── store/              # Zustand 스토어
├── hooks/              # Custom React Hooks
├── types/              # 공유 타입 정의
├── utils/              # 일반 유틸리티 함수
└── assets/             # 이미지, 사운드 등
```

## 코드 스타일 (Biome 규칙 준수)

- **인덴트**: 2 스페이스
- **따옴표**: JavaScript/TypeScript는 싱글 쿼트(`'`), JSX는 더블 쿼트(`"`)
- **세미콜론**: 항상 사용
- **줄 길이**: 최대 100자
- **화살표 함수**: 항상 괄호 사용 `(x) => x + 1`
- **Trailing Comma**: ES5 스타일 (객체, 배열 마지막 요소)
- **Import 정렬**: 자동으로 정리 (Biome)

```typescript
// Good
import type { GameState } from './types';
import { create } from 'zustand';
import { calculateScore } from './utils';

const player = {
  name: 'Player 1',
  score: 100,
  lives: 3,
};

const updateScore = (amount: number) => {
  return amount * 2;
};

// Bad
import {create} from "zustand"
import {calculateScore} from "./utils"
import { GameState } from './types'

const player = {
  name: "Player 1",
  score: 100,
  lives: 3
}

const updateScore = amount => amount * 2
```

## 에러 처리

- 조기 반환(Early Return)으로 에러 조건을 처리합니다.
- Guard Clauses를 사용하여 전제 조건을 체크합니다.
- 필요 시 커스텀 에러 타입을 생성합니다.
- Try-catch는 예측 가능한 에러에만 사용합니다.
- 에러 경계(Error Boundary)를 사용하여 React 에러를 처리합니다.

```typescript
// Good
const processPlayer = (player: Player | null) => {
  if (!player) {
    console.error('Player not found');
    return;
  }
  
  if (!player.isAlive) {
    console.warn('Player is dead');
    return;
  }
  
  // 실제 로직
  player.update();
};

// Bad
const processPlayer = (player: Player | null) => {
  if (player) {
    if (player.isAlive) {
      player.update();
    } else {
      console.warn('Player is dead');
    }
  } else {
    console.error('Player not found');
  }
};
```

## 성능 최적화

- `useMemo`와 `useCallback`은 필요할 때만 사용합니다.
- PixiJS 스프라이트는 풀링(Pooling)을 고려합니다.
- 불필요한 리렌더링을 방지하기 위해 Zustand Selector를 사용합니다.
- 무거운 계산은 Web Worker로 분리합니다.
- 이미지는 적절한 포맷과 크기로 최적화합니다.

## 스타일링 (Tailwind CSS)

- Utility-first 접근 방식을 사용합니다.
- 반복되는 스타일은 컴포넌트로 추출합니다.
- 커스텀 클래스보다는 Tailwind 유틸리티를 우선 사용합니다.
- `@apply`는 최소화합니다.

```tsx
// Good
<div className="flex items-center justify-center w-full h-screen bg-gray-100">
  <button className="px-4 py-2 text-white bg-blue-500 rounded hover:bg-blue-600">
    Start Game
  </button>
</div>

// Bad: 불필요한 커스텀 클래스
<div className="game-container">
  <button className="game-button">Start Game</button>
</div>
```

## Git 커밋 메시지

- Conventional Commits 형식을 따릅니다.
- 타입: `feat`, `fix`, `refactor`, `docs`, `style`, `test`, `chore`
- 간결하고 명확한 메시지를 작성합니다.

```
feat: add player collision detection
fix: resolve sprite flickering issue
refactor: separate game loop logic
docs: update README with setup instructions
```

## 테스팅

- 컴포넌트 테스트는 React Testing Library를 사용합니다.
- 게임 로직은 순수 함수로 작성하여 테스트 가능하게 합니다.
- 통합 테스트보다 단위 테스트를 우선합니다.
- Mock은 최소화하고 실제 구현을 테스트합니다.

## 주요 금지 사항

- 클래스 컴포넌트 사용 금지
- `any` 타입 남용 금지
- 전역 상태 남용 금지
- PixiJS 리소스 미해제 금지
- useEffect 의존성 배열 누락 금지
- 중첩된 조건문 과도한 사용 금지
- 불필요한 리렌더링 유발 금지

## 개발 워크플로우

1. **코드 작성** 전에 타입을 먼저 정의합니다.
2. **컴포넌트 분리**: UI와 로직을 명확히 분리합니다.
3. **린팅**: `npm run check` 실행하여 Biome 규칙 준수를 확인합니다.
4. **테스트**: 주요 로직은 테스트 코드를 작성합니다.
5. **커밋**: Lefthook이 자동으로 린트를 실행합니다.

## 예제: 전체 구조

```typescript
// types/game.ts
export interface GameObject {
  id: string;
  position: Position;
  velocity: Velocity;
}

export type GameState = 'idle' | 'playing' | 'paused' | 'gameover';

// game/entities/Enemy.ts
export class Enemy implements GameObject {
  id: string;
  sprite: PIXI.Sprite;
  private health: number;
  
  constructor(x: number, y: number) {
    this.id = crypto.randomUUID();
    this.sprite = PIXI.Sprite.from('enemy.png');
    this.sprite.position.set(x, y);
    this.health = 100;
  }
  
  takeDamage(amount: number): void {
    this.health = Math.max(0, this.health - amount);
  }
  
  update(delta: number): void {
    // 적 AI 로직
  }
  
  destroy(): void {
    this.sprite.destroy();
  }
}

// store/gameStore.ts
interface GameStore {
  state: GameState;
  score: number;
  enemies: string[];
  setState: (state: GameState) => void;
  addEnemy: (id: string) => void;
  removeEnemy: (id: string) => void;
}

export const useGameStore = create<GameStore>((set) => ({
  state: 'idle',
  score: 0,
  enemies: [],
  setState: (state) => set({ state }),
  addEnemy: (id) => set((state) => ({ enemies: [...state.enemies, id] })),
  removeEnemy: (id) => set((state) => ({
    enemies: state.enemies.filter((enemyId) => enemyId !== id),
  })),
}));

// components/Game.tsx
const Game = () => {
  const gameState = useGameStore((state) => state.state);
  const setState = useGameStore((state) => state.setState);
  
  if (gameState === 'idle') {
    return <StartScreen onStart={() => setState('playing')} />;
  }
  
  if (gameState === 'gameover') {
    return <GameOverScreen onRestart={() => setState('idle')} />;
  }
  
  return <GameCanvas />;
};
```

## 핵심 철학

> "간결하고, 타입 안전하며, 유지보수 가능한 코드를 작성합니다."

- 복잡성보다는 **단순함**을 선택합니다.
- 추측보다는 **명시적 타입**을 사용합니다.
- 혼합보다는 **책임의 분리**를 실천합니다.
- 최적화는 **측정 후** 진행합니다.
